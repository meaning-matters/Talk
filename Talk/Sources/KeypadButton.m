//
//  KeypadButton.m
//  Talk
//
//  Created by Cornelis van der Bent on 13/11/12.
//  Copyright (c) 2012 Cornelis van der Bent. All rights reserved.
//

#import "KeypadButton.h"
#import "Common.h"

@implementation KeypadButton

@synthesize title    = _title;
@synthesize subtitle = _subtitle;


- (id)initWithFrame:(CGRect)frame
{
    if (self = [super initWithFrame:frame])
    {
    }

    return self;
}


- (void)setHighlighted:(BOOL)highlighted
{
    if (self.isHighlighted != highlighted)
    {
        [super setHighlighted:highlighted];

        // Trigger drawRect.
        [self setNeedsDisplay];
    }
}


- (void)layoutSubviews
{
    [super layoutSubviews];
    [self setNeedsDisplay];
}


- (void)drawRect:(CGRect)rect
{
    [super drawRect:rect];

    if (self.tag == 14)
    {
        [self drawRectCall];
        return;
    }

    // Code below was generated by PaintCode: External/PaintCode/KeypadKey[Highlight].
    // But I adapted it & niced it, and combined output of two PaintCode designs.

    //// General Declarations
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = UIGraphicsGetCurrentContext();
    CGGradientRef gradient3;

    if (self.state == UIControlStateHighlighted)
    {
        //// Color Declarations
        UIColor* gradient3Color  = [UIColor colorWithRed:0.208 green:0.497 blue:1 alpha:1];
        UIColor* gradient3Color2 = [UIColor colorWithRed:0.551 green:0.713 blue:0.997 alpha:1];

        //// Gradient Declarations
        NSArray* gradient3Colors = [NSArray arrayWithObjects:
                                    (id)gradient3Color2.CGColor,
                                    (id)[UIColor colorWithRed: 0.391 green: 0.607 blue: 0.999 alpha: 1].CGColor,
                                    (id)gradient3Color.CGColor, nil];
        CGFloat gradient3Locations[] = {0, 0.49, 1};
        gradient3 = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)gradient3Colors, gradient3Locations);
    }
    else
    {
        //// Color Declarations
        UIColor* gradient3Color = [UIColor colorWithRed:0.9 green:0.9 blue:0.9 alpha:1];

        //// Gradient Declarations
        NSArray* gradient3Colors = [NSArray arrayWithObjects:
                                    (id)[UIColor whiteColor].CGColor,
                                    (id)[UIColor colorWithRed:0.95 green:0.95 blue:0.95 alpha:1].CGColor,
                                    (id)gradient3Color.CGColor, nil];
        CGFloat gradient3Locations[] = {0, 0.49, 1};
        gradient3 = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)gradient3Colors, gradient3Locations);
    }

    //// Frames
    CGRect outerFrame = self.bounds;

    //// Subframes
    CGRect innerFrame = CGRectMake(CGRectGetMinX(outerFrame) + floor((CGRectGetWidth(outerFrame) - 41) * 0.49231 + 0.5),
                                   CGRectGetMinY(outerFrame) + floor((CGRectGetHeight(outerFrame) - 47) * 0.50000 + 0.5),
                                   41, 47);

    //// Abstracted Attributes
    CGRect rectangleRect = CGRectMake(CGRectGetMinX(outerFrame) + 0.5, CGRectGetMinY(outerFrame) + 0.5,
                                      CGRectGetWidth(outerFrame) - 1, CGRectGetHeight(outerFrame) - 1);

    //// Rectangle Drawing
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: rectangleRect];
    CGContextSaveGState(context);
    [rectanglePath addClip];
    CGContextDrawLinearGradient(context, gradient3,
                                CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMaxY(rectangleRect)),
                                CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMinY(rectangleRect)),
                                0);
    CGContextRestoreGState(context);
    [[UIColor grayColor] setStroke];
    rectanglePath.lineWidth = 1;
    [rectanglePath stroke];

    if (self.title != nil)
    {
        //// Text Drawing
        CGRect textRect = CGRectMake(CGRectGetMinX(innerFrame) + 1, CGRectGetMinY(innerFrame) + 4, 41, 46);
        (self.state == UIControlStateHighlighted) ? [[UIColor whiteColor] setFill] : [[UIColor blackColor] setFill];
        [self.title drawInRect:textRect
                      withFont:[Common phoneFontOfSize:32]
                 lineBreakMode:NSLineBreakByWordWrapping
                     alignment:NSTextAlignmentCenter];

        //// Text 2 Drawing
        CGRect text2Rect = CGRectMake(CGRectGetMinX(innerFrame) - 5, CGRectGetMinY(innerFrame) + 34, 53, 15);
        (self.state == UIControlStateHighlighted) ? [[UIColor whiteColor] setFill] : [[UIColor darkGrayColor] setFill];
        [self.subtitle drawInRect:text2Rect
                         withFont:[Common phoneFontOfSize:13]
                    lineBreakMode:NSLineBreakByWordWrapping
                        alignment:NSTextAlignmentCenter];
    }
    else
    {
        //// Bezier 4 Drawing
        UIBezierPath* bezier4Path = [UIBezierPath bezierPath];
        [bezier4Path moveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 15.55, CGRectGetMinY(innerFrame) + 16.43)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 13.43, CGRectGetMinY(innerFrame) + 18.55)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 18.38, CGRectGetMinY(innerFrame) + 23.5)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 13.43, CGRectGetMinY(innerFrame) + 28.45)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 15.55, CGRectGetMinY(innerFrame) + 30.57)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 20.5, CGRectGetMinY(innerFrame) + 25.62)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 25.45, CGRectGetMinY(innerFrame) + 30.57)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 27.57, CGRectGetMinY(innerFrame) + 28.45)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 22.62, CGRectGetMinY(innerFrame) + 23.5)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 27.57, CGRectGetMinY(innerFrame) + 18.55)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 25.45, CGRectGetMinY(innerFrame) + 16.43)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 20.5, CGRectGetMinY(innerFrame) + 21.38)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 15.55, CGRectGetMinY(innerFrame) + 16.43)];
        [bezier4Path closePath];
        [bezier4Path moveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 31, CGRectGetMinY(innerFrame) + 17)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 31, CGRectGetMinY(innerFrame) + 30)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 27, CGRectGetMinY(innerFrame) + 34) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 31, CGRectGetMinY(innerFrame) + 32.21) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 29.21, CGRectGetMinY(innerFrame) + 34)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 14, CGRectGetMinY(innerFrame) + 34)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 12.29, CGRectGetMinY(innerFrame) + 33.62) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 13.39, CGRectGetMinY(innerFrame) + 34) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 12.81, CGRectGetMinY(innerFrame) + 33.86)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 10.71, CGRectGetMinY(innerFrame) + 32.79) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 11.71, CGRectGetMinY(innerFrame) + 33.5) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 11.16, CGRectGetMinY(innerFrame) + 33.22)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 3.26, CGRectGetMinY(innerFrame) + 25.69)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 3.26, CGRectGetMinY(innerFrame) + 21.31) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 1.99, CGRectGetMinY(innerFrame) + 24.48) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 1.99, CGRectGetMinY(innerFrame) + 22.52)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 10.71, CGRectGetMinY(innerFrame) + 14.21)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 12.29, CGRectGetMinY(innerFrame) + 13.38) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 11.16, CGRectGetMinY(innerFrame) + 13.78) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 11.71, CGRectGetMinY(innerFrame) + 13.5)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 14, CGRectGetMinY(innerFrame) + 13) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 12.81, CGRectGetMinY(innerFrame) + 13.14) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 13.39, CGRectGetMinY(innerFrame) + 13)];
        [bezier4Path addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 27, CGRectGetMinY(innerFrame) + 13)];
        [bezier4Path addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 31, CGRectGetMinY(innerFrame) + 17) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 29.21, CGRectGetMinY(innerFrame) + 13) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 31, CGRectGetMinY(innerFrame) + 14.79)];
        [bezier4Path closePath];
        (self.state == UIControlStateHighlighted) ? [[UIColor whiteColor] setFill] : [[UIColor blackColor] setFill];
        [bezier4Path fill];
    }

    //// Cleanup
    CGGradientRelease(gradient3);
    CGColorSpaceRelease(colorSpace);
}


- (void)drawRectCall
{
    //// General Declarations
    CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB();
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* baseColor = [UIColor colorWithRed: 0.197 green: 0.707 blue: 0.104 alpha: 1];
    CGFloat baseColorRGBA[4];
    [baseColor getRed: &baseColorRGBA[0] green: &baseColorRGBA[1] blue: &baseColorRGBA[2] alpha: &baseColorRGBA[3]];

    UIColor* topColor = [UIColor colorWithRed: (baseColorRGBA[0] * 0.8) green: (baseColorRGBA[1] * 0.8) blue: (baseColorRGBA[2] * 0.8) alpha: (baseColorRGBA[3] * 0.8 + 0.2)];
    UIColor* bottomColor = [UIColor colorWithRed: (baseColorRGBA[0] * 0.6 + 0.4) green: (baseColorRGBA[1] * 0.6 + 0.4) blue: (baseColorRGBA[2] * 0.6 + 0.4) alpha: (baseColorRGBA[3] * 0.6 + 0.4)];
    UIColor* gradientColor2 = [UIColor colorWithRed: 0.286 green: 0.654 blue: 0.221 alpha: 1];

    //// Gradient Declarations
    NSArray* buttonGradientColors = [NSArray arrayWithObjects:
                                     (id)topColor.CGColor,
                                     (id)[UIColor colorWithRed: 0.225 green: 0.622 blue: 0.154 alpha: 1].CGColor,
                                     (id)gradientColor2.CGColor,
                                     (id)[UIColor colorWithRed: 0.435 green: 0.741 blue: 0.381 alpha: 1].CGColor,
                                     (id)bottomColor.CGColor, nil];
    CGFloat buttonGradientLocations[] = {0, 0.49, 0.6, 0.85, 1};
    CGGradientRef buttonGradient = CGGradientCreateWithColors(colorSpace, (__bridge CFArrayRef)buttonGradientColors, buttonGradientLocations);

    //// Frames
    CGRect outerFrame = self.bounds;

    //// Subframes
    CGRect innerFrame = CGRectMake(CGRectGetMinX(outerFrame) + floor((CGRectGetWidth(outerFrame) - 41) * 0.49231 + 0.5), CGRectGetMinY(outerFrame) + floor((CGRectGetHeight(outerFrame) - 47) * 0.50000 + 0.5), 41, 47);


    //// Abstracted Attributes
    CGRect rectangleRect = CGRectMake(CGRectGetMinX(outerFrame) + 0.5, CGRectGetMinY(outerFrame) + 0.5, CGRectGetWidth(outerFrame) - 1, CGRectGetHeight(outerFrame) - 1);


    //// Rectangle Drawing
    UIBezierPath* rectanglePath = [UIBezierPath bezierPathWithRect: rectangleRect];
    CGContextSaveGState(context);
    [rectanglePath addClip];
    CGContextDrawLinearGradient(context, buttonGradient,
                                CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMaxY(rectangleRect)),
                                CGPointMake(CGRectGetMidX(rectangleRect), CGRectGetMinY(rectangleRect)),
                                0);
    CGContextRestoreGState(context);
    [[UIColor grayColor] setStroke];
    rectanglePath.lineWidth = 1;
    [rectanglePath stroke];


    //// phone Drawing
    UIBezierPath* phonePath = [UIBezierPath bezierPath];
    [phonePath moveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 9.55, CGRectGetMinY(innerFrame) + 4.17)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 8.68, CGRectGetMinY(innerFrame) + 3.5)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 4.95, CGRectGetMinY(innerFrame) + 3.5)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 0.92, CGRectGetMinY(innerFrame) + 8.47) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 4.95, CGRectGetMinY(innerFrame) + 3.5) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 2.12, CGRectGetMinY(innerFrame) + 4.35)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 0.92, CGRectGetMinY(innerFrame) + 15.56) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) - 0.28, CGRectGetMinY(innerFrame) + 12.59) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 0.92, CGRectGetMinY(innerFrame) + 15.56)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 0.92, CGRectGetMinY(innerFrame) + 15.56) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 0.92, CGRectGetMinY(innerFrame) + 15.56) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 0.8, CGRectGetMinY(innerFrame) + 14.84)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 9.55, CGRectGetMinY(innerFrame) + 31.97) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 1.41, CGRectGetMinY(innerFrame) + 18.44) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 4.69, CGRectGetMinY(innerFrame) + 26.78)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 24.49, CGRectGetMinY(innerFrame) + 42.35) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 14.77, CGRectGetMinY(innerFrame) + 37.56) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 21.29, CGRectGetMinY(innerFrame) + 41.67)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 31.68, CGRectGetMinY(innerFrame) + 42.02) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 27.7, CGRectGetMinY(innerFrame) + 43.04) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 29.46, CGRectGetMinY(innerFrame) + 42.89)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 35.99, CGRectGetMinY(innerFrame) + 38.67) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 33.32, CGRectGetMinY(innerFrame) + 41.38) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 35.12, CGRectGetMinY(innerFrame) + 39.71)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 36.86, CGRectGetMinY(innerFrame) + 36.99) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 36.31, CGRectGetMinY(innerFrame) + 38.3) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 36.86, CGRectGetMinY(innerFrame) + 36.99)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 36.57, CGRectGetMinY(innerFrame) + 32.31) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 36.86, CGRectGetMinY(innerFrame) + 36.99) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 37.33, CGRectGetMinY(innerFrame) + 32.7)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 33.98, CGRectGetMinY(innerFrame) + 30.97) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 35.81, CGRectGetMinY(innerFrame) + 31.91) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 33.98, CGRectGetMinY(innerFrame) + 30.97)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 29.09, CGRectGetMinY(innerFrame) + 28.29)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 27.66, CGRectGetMinY(innerFrame) + 28.29)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 24.49, CGRectGetMinY(innerFrame) + 32.31) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 27.66, CGRectGetMinY(innerFrame) + 28.29) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 25.12, CGRectGetMinY(innerFrame) + 31.46)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 22.48, CGRectGetMinY(innerFrame) + 33.31) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 23.87, CGRectGetMinY(innerFrame) + 33.15) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 22.48, CGRectGetMinY(innerFrame) + 33.31)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 15.58, CGRectGetMinY(innerFrame) + 28.29) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 22.48, CGRectGetMinY(innerFrame) + 33.31) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 18.77, CGRectGetMinY(innerFrame) + 31.27)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 10.12, CGRectGetMinY(innerFrame) + 20.92) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 12.4, CGRectGetMinY(innerFrame) + 25.3) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 10.12, CGRectGetMinY(innerFrame) + 20.92)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 10.26, CGRectGetMinY(innerFrame) + 19.07)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 12.71, CGRectGetMinY(innerFrame) + 15.89) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 10.26, CGRectGetMinY(innerFrame) + 19.07) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 12.77, CGRectGetMinY(innerFrame) + 15.89)];
    [phonePath addCurveToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 13.28, CGRectGetMinY(innerFrame) + 13.88) controlPoint1: CGPointMake(CGRectGetMinX(innerFrame) + 12.64, CGRectGetMinY(innerFrame) + 15.89) controlPoint2: CGPointMake(CGRectGetMinX(innerFrame) + 13.28, CGRectGetMinY(innerFrame) + 13.88)];
    [phonePath addLineToPoint: CGPointMake(CGRectGetMinX(innerFrame) + 9.55, CGRectGetMinY(innerFrame) + 4.17)];
    [phonePath closePath];
    [[UIColor whiteColor] setFill];
    [phonePath fill];
    
    
    //// Cleanup
    CGGradientRelease(buttonGradient);
    CGColorSpaceRelease(colorSpace);
}

@end
